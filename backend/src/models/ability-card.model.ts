/**
 * AbilityCard Model (US2 - T087)
 *
 * Represents a playable action card with initiative, top action,
 * bottom action, and typed modifiers. Each character class has
 * a unique deck of ability cards.
 *
 * Updated to use the new modifier system (Issue #220).
 */

import {
  CardAction,
  ElementType,
  CharacterClass,
  Modifier,
  InfuseModifier,
  ConsumeModifier,
  isLostAction,
  isPersistent,
  getXPValue,
  getRange,
} from '../../../shared/types/entities';

export interface AbilityCardData {
  id: string;
  characterClass: CharacterClass;
  name: string;
  level: number | 'X';
  initiative: number;
  topAction: CardAction;
  bottomAction: CardAction;
  imageUrl?: string;
  createdAt: Date;
}

export class AbilityCard {
  public readonly id: string;
  public readonly characterClass: CharacterClass;
  public readonly name: string;
  public readonly level: number | 'X';
  public readonly initiative: number;
  private readonly _topAction: CardAction;
  private readonly _bottomAction: CardAction;
  public readonly imageUrl?: string;
  private readonly _createdAt: Date;

  constructor(data: AbilityCardData) {
    this.id = data.id;
    this.characterClass = data.characterClass;
    this.name = data.name;
    this.level = data.level;
    this.initiative = data.initiative;
    this._topAction = data.topAction;
    this._bottomAction = data.bottomAction;
    this.imageUrl = data.imageUrl;
    this._createdAt = data.createdAt;

    this.validate();
  }

  // Getters
  get topAction(): Readonly<CardAction> {
    return { ...this._topAction };
  }

  get bottomAction(): Readonly<CardAction> {
    return { ...this._bottomAction };
  }

  get createdAt(): Date {
    return this._createdAt;
  }

  get isStarterCard(): boolean {
    return this.level === 1;
  }

  get isLevelUpCard(): boolean {
    return this.level === 'X';
  }

  get generatesElement(): boolean {
    return !!(
      this.getElementGenerated('top') || this.getElementGenerated('bottom')
    );
  }

  get consumesElement(): boolean {
    return !!(
      this.getElementConsumed('top') || this.getElementConsumed('bottom')
    );
  }

  // Methods
  private validate(): void {
    if (this.initiative < 1 || this.initiative > 99) {
      throw new Error('Initiative must be between 1 and 99');
    }

    if (typeof this.level === 'number' && (this.level < 1 || this.level > 9)) {
      throw new Error('Level must be between 1 and 9, or "X"');
    }

    if (!this.name || this.name.trim().length === 0) {
      throw new Error('Card name cannot be empty');
    }
  }

  getActionByPosition(position: 'top' | 'bottom'): Readonly<CardAction> {
    return position === 'top' ? this.topAction : this.bottomAction;
  }

  /**
   * Get the element generated by an action (from infuse modifiers)
   */
  getElementGenerated(position: 'top' | 'bottom'): ElementType | null {
    const action = this.getActionByPosition(position);
    const modifiers = action.modifiers || [];
    const infuseModifier = modifiers.find(
      (m): m is InfuseModifier => m.type === 'infuse',
    );
    return infuseModifier?.element || null;
  }

  /**
   * Get the element consumed by an action (from consume modifiers)
   */
  getElementConsumed(position: 'top' | 'bottom'): ElementType | null {
    const action = this.getActionByPosition(position);
    const modifiers = action.modifiers || [];
    const consumeModifier = modifiers.find(
      (m): m is ConsumeModifier => m.type === 'consume',
    );
    return consumeModifier?.element || null;
  }

  /**
   * Get the element bonus from a consume modifier
   */
  getElementBonus(
    position: 'top' | 'bottom',
  ): { effect: string; value: number } | null {
    const action = this.getActionByPosition(position);
    const modifiers = action.modifiers || [];
    const consumeModifier = modifiers.find(
      (m): m is ConsumeModifier => m.type === 'consume',
    );
    if (consumeModifier?.bonus) {
      return {
        effect: consumeModifier.bonus.effect,
        value: consumeModifier.bonus.value,
      };
    }
    return null;
  }

  /**
   * Check if action is a lost action (goes to lost pile after use)
   */
  isLostAction(position: 'top' | 'bottom'): boolean {
    const action = this.getActionByPosition(position);
    return isLostAction(action.modifiers || []);
  }

  /**
   * Check if action has a persistent effect
   */
  isPersistentAction(position: 'top' | 'bottom'): boolean {
    const action = this.getActionByPosition(position);
    return isPersistent(action.modifiers || []);
  }

  /**
   * Get XP value for an action
   */
  getXPValue(position: 'top' | 'bottom'): number {
    const action = this.getActionByPosition(position);
    return getXPValue(action.modifiers || []);
  }

  /**
   * Get range for an action
   */
  getRange(position: 'top' | 'bottom'): number {
    const action = this.getActionByPosition(position);
    return getRange(action.modifiers || []);
  }

  /**
   * Get all modifiers for an action
   */
  getModifiers(position: 'top' | 'bottom'): Modifier[] {
    const action = this.getActionByPosition(position);
    return action.modifiers || [];
  }

  hasActionType(type: CardAction['type']): boolean {
    return this._topAction.type === type || this._bottomAction.type === type;
  }

  isAttackCard(): boolean {
    return this.hasActionType('attack');
  }

  isMoveCard(): boolean {
    return this.hasActionType('move');
  }

  isHealCard(): boolean {
    return this.hasActionType('heal');
  }

  toJSON(): AbilityCardData {
    return {
      id: this.id,
      characterClass: this.characterClass,
      name: this.name,
      level: this.level,
      initiative: this.initiative,
      topAction: this._topAction,
      bottomAction: this._bottomAction,
      imageUrl: this.imageUrl,
      createdAt: this._createdAt,
    };
  }

  /**
   * Create a new AbilityCard instance
   */
  static create(
    characterClass: CharacterClass,
    name: string,
    level: number | 'X',
    initiative: number,
    topAction: CardAction,
    bottomAction: CardAction,
    imageUrl?: string,
  ): AbilityCard {
    return new AbilityCard({
      id: `card_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      characterClass,
      name,
      level,
      initiative,
      topAction,
      bottomAction,
      imageUrl,
      createdAt: new Date(),
    });
  }

  /**
   * Get starter deck for a character class (level 1 cards)
   * Note: This is now deprecated - use AbilityCardService.getCardsByClass instead,
   * which loads cards from ability-cards.json with the new modifier format.
   */
  static getStarterDeck(characterClass: CharacterClass): AbilityCard[] {
    // Brute starter cards using new modifier format
    const bruteCards: Omit<
      AbilityCardData,
      'id' | 'createdAt' | 'characterClass'
    >[] = [
      {
        name: 'Trample',
        level: 1,
        initiative: 72,
        topAction: {
          type: 'attack',
          value: 3,
          modifiers: [{ type: 'push', distance: 1 }],
        },
        bottomAction: {
          type: 'move',
          value: 3,
        },
      },
      {
        name: 'Provoking Roar',
        level: 1,
        initiative: 10,
        topAction: {
          type: 'attack',
          value: 2,
        },
        bottomAction: {
          type: 'special',
          special: 'All adjacent enemies focus on you',
        },
      },
      {
        name: 'Warding Strength',
        level: 1,
        initiative: 32,
        topAction: {
          type: 'attack',
          value: 3,
        },
        bottomAction: {
          type: 'special',
          modifiers: [{ type: 'shield', value: 1, duration: 'round' }],
        },
      },
      {
        name: 'Eye for an Eye',
        level: 1,
        initiative: 18,
        topAction: {
          type: 'attack',
          value: 2,
          modifiers: [{ type: 'retaliate', value: 2, duration: 'round' }],
        },
        bottomAction: {
          type: 'move',
          value: 4,
        },
      },
      {
        name: 'Spare Dagger',
        level: 1,
        initiative: 27,
        topAction: {
          type: 'attack',
          value: 2,
          modifiers: [{ type: 'range', distance: 2 }],
        },
        bottomAction: {
          type: 'move',
          value: 3,
        },
      },
      {
        name: 'Sweeping Blow',
        level: 1,
        initiative: 64,
        topAction: {
          type: 'attack',
          value: 2,
          modifiers: [{ type: 'target', count: 3 }], // Attack all adjacent
        },
        bottomAction: {
          type: 'move',
          value: 2,
        },
      },
      {
        name: 'Skewer',
        level: 1,
        initiative: 77,
        topAction: {
          type: 'attack',
          value: 4,
        },
        bottomAction: {
          type: 'move',
          value: 2,
        },
      },
      {
        name: 'Shield Bash',
        level: 1,
        initiative: 15,
        topAction: {
          type: 'attack',
          value: 1,
          modifiers: [
            { type: 'push', distance: 2 },
            { type: 'condition', condition: 'stun' as any, duration: 'round' },
          ],
        },
        bottomAction: {
          type: 'move',
          value: 3,
        },
      },
      {
        name: 'Overwhelming Assault',
        level: 1,
        initiative: 52,
        topAction: {
          type: 'attack',
          value: 3,
          modifiers: [{ type: 'target', count: 3 }], // Target all adjacent
        },
        bottomAction: {
          type: 'move',
          value: 1,
        },
      },
      {
        name: 'Leaping Cleave',
        level: 1,
        initiative: 84,
        topAction: {
          type: 'attack',
          value: 3,
        },
        bottomAction: {
          type: 'move',
          value: 4,
          modifiers: [{ type: 'jump' }],
        },
      },
    ];

    // For now, only Brute cards are implemented
    // Other classes would have their own starter decks
    const cardTemplates =
      characterClass === CharacterClass.BRUTE ? bruteCards : [];

    return cardTemplates.map((template) =>
      AbilityCard.create(
        characterClass,
        template.name,
        template.level,
        template.initiative,
        template.topAction,
        template.bottomAction,
        template.imageUrl,
      ),
    );
  }

  /**
   * Compare two cards by initiative (for turn order sorting)
   */
  static compareByInitiative(a: AbilityCard, b: AbilityCard): number {
    return a.initiative - b.initiative;
  }
}
