// Hexhaven Multiplayer - Prisma Schema
// Integrated: Anonymous gameplay (001) + User authentication & progression (002)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========== USER AUTHENTICATION (002) ==========

model User {
  id                  String    @id @default(uuid()) @db.Uuid
  username            String    @unique @db.VarChar(20)
  passwordHash        String    @db.VarChar(255)
  email               String?   @unique @db.VarChar(255) // Reserved for future use
  roles               Json      @default("[\"player\"]") // ["player", "creator", "admin"] - RBAC (Issue #205)
  failedLoginAttempts Int       @default(0) @db.SmallInt
  lockedUntil         DateTime?
  deletedAt           DateTime? // Soft delete timestamp
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  // Relations
  refreshTokens     RefreshToken[]
  characters        Character[]
  playerGameResults PlayerGameResult[]

  @@index([username])
  @@index([deletedAt])
  @@map("users")
}

model RefreshToken {
  id        String   @id @default(uuid()) @db.Uuid
  token     String   @unique @db.VarChar(255)
  userId    String   @db.Uuid
  expiresAt DateTime
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

// ========== CHARACTER CLASSES & ABILITIES (002) ==========

model CharacterClass {
  id               String   @id @default(uuid()) @db.Uuid
  name             String   @unique @db.VarChar(50) // "Brute", "Tinkerer", "Spellweaver", etc.
  startingHealth   Int      @db.SmallInt
  maxHealthByLevel Json // Array of max health per level [10, 12, 14, ...]
  handSize         Int      @db.SmallInt // Number of cards in hand
  perks            Json // Array of available perks ["Remove two -1 cards", ...]
  description      String   @db.VarChar(500)
  imageUrl         String?  @db.VarChar(255)
  createdAt        DateTime @default(now())

  // Relations
  characters   Character[]
  abilityCards AbilityCard[]

  @@map("character_classes")
}

model CardLayoutTemplate {
  id          String   @id @default(uuid()) @db.Uuid
  name        String   @unique @db.VarChar(100) // "ability-card-default", "ability-card-compact", "summon-card"
  description String?  @db.VarChar(500)
  modules     Json // Array of module configurations
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  abilityCards AbilityCard[]

  @@map("card_layout_templates")
}

model AbilityCard {
  id               String              @id @default(uuid()) @db.Uuid
  classId          String              @db.Uuid
  name             String              @db.VarChar(100)
  level            Int                 @db.SmallInt // Level X = starting card (level 0 or 1)
  initiative       Int                 @db.SmallInt // Turn order value
  topAction        Json // { type, value, effects, range }
  bottomAction     Json // { type, value, effects }
  layoutTemplateId String?             @db.Uuid // NULL uses default template
  createdAt        DateTime            @default(now())

  // Relations
  class          CharacterClass       @relation(fields: [classId], references: [id], onDelete: Cascade)
  layoutTemplate CardLayoutTemplate?  @relation(fields: [layoutTemplateId], references: [id], onDelete: SetNull)
  enhancements   CardEnhancement[]

  @@index([classId])
  @@index([level])
  @@index([layoutTemplateId])
  @@map("ability_cards")
}

// ========== CHARACTERS & PROGRESSION (002) ==========

model Character {
  id            String   @id @default(uuid()) @db.Uuid
  name          String   @db.VarChar(30)
  userId        String   @db.Uuid
  classId       String   @db.Uuid
  level         Int      @default(1) @db.SmallInt
  experience    Int      @default(0)
  gold          Int      @default(0)
  health        Int      @db.SmallInt // Current health
  perks         Json     @default("[]") // Array of unlocked perk names
  currentGameId String?  @db.Uuid // NULL if not in game, gameId if in active game
  campaignId    String?  @db.Uuid // NULL or campaignId (features deferred)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  user            User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  class           CharacterClass       @relation(fields: [classId], references: [id])
  currentGame     Game?                @relation("CharacterCurrentGame", fields: [currentGameId], references: [id], onDelete: SetNull)
  campaign        Campaign?            @relation(fields: [campaignId], references: [id], onDelete: SetNull)
  enhancements    CardEnhancement[]
  ownedItems      CharacterInventory[] // Items owned by this character (Issue #205)
  equippedItems   CharacterEquipment[] // Currently equipped items (Issue #205)
  itemStates      CharacterItemState[] // Runtime state of items during gameplay (Issue #205)

  @@index([userId])
  @@index([classId])
  @@index([currentGameId])
  @@index([campaignId])
  @@map("characters")
}

// ========== CHARACTER INVENTORY & EQUIPMENT (Issue #205) ==========

model CharacterInventory {
  id          String   @id @default(uuid()) @db.Uuid
  characterId String   @db.Uuid
  itemId      String   @db.Uuid
  acquiredAt  DateTime @default(now())

  // Relations
  character Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  item      Item      @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([characterId, itemId]) // Can only own each item once
  @@index([characterId])
  @@index([itemId])
  @@map("character_inventory")
}

model CharacterEquipment {
  id          String   @id @default(uuid()) @db.Uuid
  characterId String   @db.Uuid
  itemId      String   @db.Uuid
  slot        ItemSlot // HEAD, BODY, LEGS, ONE_HAND, TWO_HAND, SMALL
  slotIndex   Int      @default(0) @db.SmallInt // For slots with multiple items (hands: 0-1, small: 0-N)
  equippedAt  DateTime @default(now())

  // Relations
  character Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  item      Item      @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([characterId, slot, slotIndex]) // Only one item per slot+index
  @@unique([characterId, itemId]) // Can't equip same item twice
  @@index([characterId])
  @@index([itemId])
  @@map("character_equipment")
}

model CharacterItemState {
  id            String    @id @default(uuid()) @db.Uuid
  characterId   String    @db.Uuid
  itemId        String    @db.Uuid
  state         ItemState @default(READY)
  usesRemaining Int?      @db.SmallInt
  updatedAt     DateTime  @updatedAt

  // Relations
  character Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  item      Item      @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([characterId, itemId]) // One state per character+item
  @@index([characterId])
  @@index([itemId])
  @@map("character_item_states")
}

model CardEnhancement {
  id              String          @id @default(uuid()) @db.Uuid
  characterId     String          @db.Uuid
  cardId          String          @db.Uuid
  slot            EnhancementSlot // TOP or BOTTOM
  enhancementType String          @db.VarChar(50) // "+1 Attack", "Add Element", etc.
  appliedAt       DateTime        @default(now())

  // Relations
  character Character   @relation(fields: [characterId], references: [id], onDelete: Cascade)
  card      AbilityCard @relation(fields: [cardId], references: [id], onDelete: Cascade)

  @@index([characterId])
  @@index([cardId])
  @@map("card_enhancements")
}

// ========== ITEMS (002, Updated for #205) ==========

model Item {
  id                  String        @id @default(uuid()) @db.Uuid
  name                String        @unique @db.VarChar(100)
  slot                ItemSlot      // HEAD, BODY, LEGS, ONE_HAND, TWO_HAND, SMALL
  usageType           ItemUsageType // PERSISTENT, SPENT, CONSUMED
  maxUses             Int?          @db.SmallInt // For multi-use items
  rarity              Rarity
  effects             Json          // Array of ItemEffect objects
  triggers            Json?         // Array of ItemTrigger objects for reactive items
  modifierDeckImpact  Json?         // { adds: ["-1", "-1"] } for items affecting attack deck
  cost                Int           // Gold cost
  description         String?       @db.VarChar(500)
  imageUrl            String?       @db.VarChar(500) // Icon class (e.g., "ra-potion")
  createdBy           String?       @db.Uuid // User ID of creator (for role-based creation)
  createdAt           DateTime      @default(now())

  // Relations (Issue #205)
  ownedBy    CharacterInventory[]
  equippedBy CharacterEquipment[]
  states     CharacterItemState[]

  @@index([slot])
  @@index([rarity])
  @@map("items")
}

// ========== GAMES & EVENT SOURCING (002) ==========

model Game {
  id          String      @id @default(uuid()) @db.Uuid
  roomCode    String      @unique @db.VarChar(6)
  scenarioId  String?     @db.Uuid
  difficulty  Int         @default(1) @db.SmallInt
  status      GameStatus  @default(LOBBY)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  startedAt   DateTime?
  completedAt DateTime?

  // Relations
  scenario         Scenario?   @relation(fields: [scenarioId], references: [id])
  gameState        GameState?
  events           GameEvent[]
  activeCharacters Character[] @relation("CharacterCurrentGame")
  gameResult       GameResult?

  @@index([roomCode])
  @@index([status])
  @@index([createdAt])
  @@map("games")
}

model GameState {
  id          String   @id @default(uuid()) @db.Uuid
  gameId      String   @unique @db.Uuid
  sequenceNum Int // Snapshot at this event sequence number
  stateData   Json // Complete game state snapshot
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@map("game_states")
}

model GameEvent {
  id          String   @id @default(uuid()) @db.Uuid
  gameId      String   @db.Uuid
  sequenceNum Int // Incremental event number for this game
  eventType   String   @db.VarChar(50) // GAME_CREATED, PLAYER_JOINED, etc.
  eventData   Json // Event payload
  playerId    String?  @db.Uuid // Player who triggered event (nullable for system events)
  createdAt   DateTime @default(now())

  // Relations
  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@unique([gameId, sequenceNum])
  @@index([gameId, sequenceNum])
  @@map("game_events")
}

// ========== GAME RESULTS (186 - Game Completion) ==========

model GameResult {
  id                          String             @id @default(uuid()) @db.Uuid
  gameId                      String             @unique @db.Uuid
  roomCode                    String             @db.VarChar(6)
  scenarioId                  String?            @db.Uuid
  scenarioName                String?            @db.VarChar(100)
  victory                     Boolean
  completedAt                 DateTime           @default(now())
  roundsCompleted             Int                @db.SmallInt
  completionTimeMs            Int? // Duration from game start to completion in milliseconds

  // Objective tracking
  primaryObjectiveCompleted   Boolean            @default(false)
  secondaryObjectiveCompleted Boolean            @default(false)
  objectivesCompletedList     Json               @default("[]") // Array of completed objective IDs
  objectiveProgress           Json               @default("{}") // { objectiveId: { current, target, completed } }

  // Aggregate stats
  totalLootCollected          Int                @default(0)
  totalExperience             Int                @default(0)
  totalGold                   Int                @default(0)

  createdAt                   DateTime           @default(now())

  // Relations
  game          Game               @relation(fields: [gameId], references: [id], onDelete: Cascade)
  playerResults PlayerGameResult[]

  @@index([gameId])
  @@index([completedAt])
  @@index([victory])
  @@map("game_results")
}

model PlayerGameResult {
  id              String      @id @default(uuid()) @db.Uuid
  gameResultId    String      @db.Uuid
  userId          String      @db.Uuid
  characterId     String      @db.Uuid
  characterClass  String      @db.VarChar(50)
  characterName   String      @db.VarChar(30)

  // Survival stats
  survived        Boolean     @default(true)
  wasExhausted    Boolean     @default(false)

  // Combat stats
  damageDealt     Int         @default(0)
  damageTaken     Int         @default(0)
  monstersKilled  Int         @default(0)

  // Resource stats
  lootCollected   Int         @default(0)
  cardsLost       Int         @default(0)

  // Rewards
  experienceGained Int        @default(0)
  goldGained       Int        @default(0)

  createdAt       DateTime    @default(now())

  // Relations
  gameResult GameResult @relation(fields: [gameResultId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([gameResultId])
  @@index([userId])
  @@index([characterId])
  @@map("player_game_results")
}

// ========== CAMPAIGNS (002 - Schema only, features deferred) ==========

model Campaign {
  id                 String   @id @default(uuid()) @db.Uuid
  name               String   @db.VarChar(100)
  prosperityLevel    Int      @default(1) @db.SmallInt
  reputation         Int      @default(0) @db.SmallInt
  completedScenarios Json     @default("[]") // Array of scenario IDs
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Relations
  characters Character[]

  @@map("campaigns")
}

// ========== SCENARIOS (001 + 002) ==========

model Scenario {
  id                   String   @id @default(uuid()) @db.Uuid
  name                 String   @unique @db.VarChar(100)
  difficulty           Int      @db.SmallInt
  mapLayout            Json // Array of HexTile objects
  monsterGroups        Json // Array of MonsterGroup objects
  objectives           Json // { primary, secondary }
  treasures            Json? // Array of treasure locations
  playerStartPositions Json? // Array of starting hex coordinates
  createdAt            DateTime @default(now())

  // Background image configuration (Issue #191)
  backgroundImageUrl   String?  @db.VarChar(500) // URL or path to background image
  backgroundOpacity    Float?   @default(1.0) // Opacity 0.0 to 1.0
  backgroundOffsetX    Int?     @default(0) // X offset in pixels
  backgroundOffsetY    Int?     @default(0) // Y offset in pixels
  backgroundScale      Float?   @default(1.0) // Scale multiplier (0.5 to 3.0)
  backgroundAnchors    Json?    // Two-anchor alignment data (Issue #191)

  // Relations
  games Game[]

  @@index([difficulty])
  @@map("scenarios")
}

// ========== ANONYMOUS GAMEPLAY (001 - Legacy) ==========

// GameRoom and Player models are kept for backward compatibility
// with existing 001 anonymous gameplay. New authenticated games use Game model.

model GameRoom {
  id         String     @id @default(uuid()) @db.Uuid
  roomCode   String     @unique @db.VarChar(6)
  status     RoomStatus @default(lobby)
  scenarioId String?    @db.Uuid
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  expiresAt  DateTime // 24-hour TTL for anonymous games

  // Relations
  players Player[]

  @@index([roomCode])
  @@index([status])
  @@index([expiresAt])
  @@map("game_rooms")
}

model Player {
  id               String           @id @default(uuid()) @db.Uuid
  uuid             String           @unique @db.VarChar(36)
  nickname         String           @db.VarChar(50)
  roomId           String?          @db.Uuid
  isHost           Boolean          @default(false)
  connectionStatus ConnectionStatus @default(connected)
  lastSeenAt       DateTime         @default(now())
  createdAt        DateTime         @default(now())

  // Relations
  room GameRoom? @relation(fields: [roomId], references: [id], onDelete: SetNull)

  @@index([uuid])
  @@index([roomId])
  @@map("players")
}

// ========== ENUMS ==========

enum GameStatus {
  LOBBY
  ACTIVE
  COMPLETED
  ABANDONED

  @@map("game_status")
}

enum RoomStatus {
  lobby
  active
  completed
  abandoned

  @@map("room_status")
}

enum ConnectionStatus {
  connected
  disconnected
  reconnecting

  @@map("connection_status")
}

enum EnhancementSlot {
  TOP
  BOTTOM

  @@map("enhancement_slot")
}

enum Rarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY

  @@map("rarity")
}

// ========== ITEM ENUMS (Issue #205) ==========

enum ItemSlot {
  HEAD
  BODY
  LEGS
  ONE_HAND
  TWO_HAND
  SMALL

  @@map("item_slot")
}

enum ItemUsageType {
  PERSISTENT // No usage limits
  SPENT      // Refresh on long rest
  CONSUMED   // Refresh between scenarios

  @@map("item_usage_type")
}

enum ItemState {
  READY    // Item is ready to use
  SPENT    // Item has been used, refreshes on long rest
  CONSUMED // Item has been consumed, refreshes between scenarios

  @@map("item_state")
}
