// Hexhaven Multiplayer - Prisma Schema
// Integrated: Anonymous gameplay (001) + User authentication & progression (002)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========== USER AUTHENTICATION (002) ==========

model User {
  id                  String    @id @default(uuid()) @db.Uuid
  username            String    @unique @db.VarChar(20)
  passwordHash        String    @db.VarChar(255)
  email               String?   @unique @db.VarChar(255) // Reserved for future use
  roles               Json      @default("[\"player\"]") // ["player", "creator", "admin"] - RBAC (Issue #205)
  failedLoginAttempts Int       @default(0) @db.SmallInt
  lockedUntil         DateTime?
  deletedAt           DateTime? // Soft delete timestamp
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  // Relations
  refreshTokens     RefreshToken[]
  characters        Character[]
  playerGameResults PlayerGameResult[]

  @@index([username])
  @@index([deletedAt])
  @@map("users")
}

model RefreshToken {
  id        String   @id @default(uuid()) @db.Uuid
  token     String   @unique @db.VarChar(255)
  userId    String   @db.Uuid
  expiresAt DateTime
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

// ========== CHARACTER CLASSES & ABILITIES (002) ==========

model CharacterClass {
  id               String   @id @default(uuid()) @db.Uuid
  name             String   @unique @db.VarChar(50) // "Brute", "Tinkerer", "Spellweaver", etc.
  startingHealth   Int      @db.SmallInt
  maxHealthByLevel Json // Array of max health per level [10, 12, 14, ...]
  handSize         Int      @db.SmallInt // Number of cards in hand
  perks            Json // Array of available perks ["Remove two -1 cards", ...]
  description      String   @db.VarChar(500)
  imageUrl         String?  @db.VarChar(255)
  createdAt        DateTime @default(now())

  // Relations
  characters   Character[]
  abilityCards AbilityCard[]

  @@map("character_classes")
}

model CardLayoutTemplate {
  id          String   @id @default(uuid()) @db.Uuid
  name        String   @unique @db.VarChar(100) // "ability-card-default", "ability-card-compact", "summon-card"
  description String?  @db.VarChar(500)
  modules     Json // Array of module configurations
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  abilityCards AbilityCard[]

  @@map("card_layout_templates")
}

model AbilityCard {
  id               String              @id @default(uuid()) @db.Uuid
  classId          String              @db.Uuid
  name             String              @db.VarChar(100)
  level            Int                 @db.SmallInt // Level X = starting card (level 0 or 1)
  initiative       Int                 @db.SmallInt // Turn order value
  topAction        Json // { type, value, effects, range }
  bottomAction     Json // { type, value, effects }
  layoutTemplateId String?             @db.Uuid // NULL uses default template
  createdAt        DateTime            @default(now())

  // Relations
  class          CharacterClass       @relation(fields: [classId], references: [id], onDelete: Cascade)
  layoutTemplate CardLayoutTemplate?  @relation(fields: [layoutTemplateId], references: [id], onDelete: SetNull)
  enhancements   CardEnhancement[]

  @@index([classId])
  @@index([level])
  @@index([layoutTemplateId])
  @@map("ability_cards")
}

// ========== CHARACTERS & PROGRESSION (002) ==========

model Character {
  id            String   @id @default(uuid()) @db.Uuid
  name          String   @db.VarChar(30)
  userId        String   @db.Uuid
  classId       String   @db.Uuid
  level         Int      @default(1) @db.SmallInt
  experience    Int      @default(0)
  gold          Int      @default(0)
  health        Int      @db.SmallInt // Current health
  perks         Json     @default("[]") // Array of unlocked perk names
  currentGameId String?  @db.Uuid // NULL if not in game, gameId if in active game
  campaignId    String?  @db.Uuid // NULL or campaignId (features deferred)
  retired       Boolean  @default(false) // Character retired in campaign (permadeath mode)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  user              User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  class             CharacterClass       @relation(fields: [classId], references: [id])
  currentGame       Game?                @relation("CharacterCurrentGame", fields: [currentGameId], references: [id], onDelete: SetNull)
  campaign          Campaign?            @relation(fields: [campaignId], references: [id], onDelete: SetNull)
  enhancements      CardEnhancement[]
  ownedItems        CharacterInventory[] // Items owned by this character (Issue #205)
  equippedItems     CharacterEquipment[] // Currently equipped items (Issue #205)
  itemStates        CharacterItemState[] // Runtime state of items during gameplay (Issue #205)
  shopTransactions  ShopTransaction[]    // Shop purchase/sell history (Issue #328)

  @@index([userId])
  @@index([classId])
  @@index([currentGameId])
  @@index([campaignId])
  @@map("characters")
}

// ========== CHARACTER INVENTORY & EQUIPMENT (Issue #205) ==========

model CharacterInventory {
  id          String   @id @default(uuid()) @db.Uuid
  characterId String   @db.Uuid
  itemId      String   @db.Uuid
  acquiredAt  DateTime @default(now())

  // Relations
  character Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  item      Item      @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([characterId, itemId]) // Can only own each item once
  @@index([characterId])
  @@index([itemId])
  @@map("character_inventory")
}

model CharacterEquipment {
  id          String   @id @default(uuid()) @db.Uuid
  characterId String   @db.Uuid
  itemId      String   @db.Uuid
  slot        ItemSlot // HEAD, BODY, LEGS, ONE_HAND, TWO_HAND, SMALL
  slotIndex   Int      @default(0) @db.SmallInt // For slots with multiple items (hands: 0-1, small: 0-N)
  equippedAt  DateTime @default(now())

  // Relations
  character Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  item      Item      @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([characterId, slot, slotIndex]) // Only one item per slot+index
  @@unique([characterId, itemId]) // Can't equip same item twice
  @@index([characterId])
  @@index([itemId])
  @@map("character_equipment")
}

model CharacterItemState {
  id            String    @id @default(uuid()) @db.Uuid
  characterId   String    @db.Uuid
  itemId        String    @db.Uuid
  state         ItemState @default(READY)
  usesRemaining Int?      @db.SmallInt
  updatedAt     DateTime  @updatedAt

  // Relations
  character Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  item      Item      @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([characterId, itemId]) // One state per character+item
  @@index([characterId])
  @@index([itemId])
  @@map("character_item_states")
}

model CardEnhancement {
  id              String          @id @default(uuid()) @db.Uuid
  characterId     String          @db.Uuid
  cardId          String          @db.Uuid
  slot            EnhancementSlot // TOP or BOTTOM
  enhancementType String          @db.VarChar(50) // "+1 Attack", "Add Element", etc.
  appliedAt       DateTime        @default(now())

  // Relations
  character Character   @relation(fields: [characterId], references: [id], onDelete: Cascade)
  card      AbilityCard @relation(fields: [cardId], references: [id], onDelete: Cascade)

  @@index([characterId])
  @@index([cardId])
  @@map("card_enhancements")
}

// ========== ITEMS (002, Updated for #205) ==========

model Item {
  id                  String        @id @default(uuid()) @db.Uuid
  name                String        @unique @db.VarChar(100)
  slot                ItemSlot      // HEAD, BODY, LEGS, ONE_HAND, TWO_HAND, SMALL
  usageType           ItemUsageType // PERSISTENT, SPENT, CONSUMED
  maxUses             Int?          @db.SmallInt // For multi-use items
  rarity              Rarity
  effects             Json          // Array of ItemEffect objects
  triggers            Json?         // Array of ItemTrigger objects for reactive items
  modifierDeckImpact  Json?         // { adds: ["-1", "-1"] } for items affecting attack deck
  cost                Int           // Gold cost
  description         String?       @db.VarChar(500)
  imageUrl            String?       @db.VarChar(500) // Icon class (e.g., "ra-potion")
  createdBy           String?       @db.Uuid // User ID of creator (for role-based creation)
  createdAt           DateTime      @default(now())

  // Relations (Issue #205)
  ownedBy         CharacterInventory[]
  equippedBy      CharacterEquipment[]
  states          CharacterItemState[]
  // Relations (Issue #328)
  shopInventory   CampaignShopInventory[]
  transactions    ShopTransaction[]

  @@index([slot])
  @@index([rarity])
  @@map("items")
}

// ========== GAMES & EVENT SOURCING (002) ==========

model Game {
  id          String      @id @default(uuid()) @db.Uuid
  roomCode    String      @unique @db.VarChar(6)
  scenarioId  String?     @db.Uuid
  campaignId  String?     @db.Uuid // Campaign this game belongs to (Issue #244)
  difficulty  Int         @default(1) @db.SmallInt
  status      GameStatus  @default(LOBBY)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  startedAt   DateTime?
  completedAt DateTime?

  // Relations
  scenario         Scenario?   @relation(fields: [scenarioId], references: [id])
  campaign         Campaign?   @relation(fields: [campaignId], references: [id])
  gameState        GameState?
  events           GameEvent[]
  activeCharacters Character[] @relation("CharacterCurrentGame")
  gameResult       GameResult?

  @@index([roomCode])
  @@index([status])
  @@index([createdAt])
  @@index([campaignId])
  @@map("games")
}

model GameState {
  id          String   @id @default(uuid()) @db.Uuid
  gameId      String   @unique @db.Uuid
  sequenceNum Int // Snapshot at this event sequence number
  stateData   Json // Complete game state snapshot
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@map("game_states")
}

model GameEvent {
  id          String   @id @default(uuid()) @db.Uuid
  gameId      String   @db.Uuid
  sequenceNum Int // Incremental event number for this game
  eventType   String   @db.VarChar(50) // GAME_CREATED, PLAYER_JOINED, etc.
  eventData   Json // Event payload
  playerId    String?  @db.Uuid // Player who triggered event (nullable for system events)
  createdAt   DateTime @default(now())

  // Relations
  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@unique([gameId, sequenceNum])
  @@index([gameId, sequenceNum])
  @@map("game_events")
}

// ========== GAME RESULTS (186 - Game Completion) ==========

model GameResult {
  id                          String             @id @default(uuid()) @db.Uuid
  gameId                      String             @unique @db.Uuid
  roomCode                    String             @db.VarChar(6)
  scenarioId                  String?            @db.Uuid
  scenarioName                String?            @db.VarChar(100)
  victory                     Boolean
  completedAt                 DateTime           @default(now())
  roundsCompleted             Int                @db.SmallInt
  completionTimeMs            Int? // Duration from game start to completion in milliseconds

  // Objective tracking
  primaryObjectiveCompleted   Boolean            @default(false)
  secondaryObjectiveCompleted Boolean            @default(false)
  objectivesCompletedList     Json               @default("[]") // Array of completed objective IDs
  objectiveProgress           Json               @default("{}") // { objectiveId: { current, target, completed } }

  // Aggregate stats
  totalLootCollected          Int                @default(0)
  totalExperience             Int                @default(0)
  totalGold                   Int                @default(0)

  createdAt                   DateTime           @default(now())

  // Relations
  game          Game               @relation(fields: [gameId], references: [id], onDelete: Cascade)
  playerResults PlayerGameResult[]

  @@index([gameId])
  @@index([completedAt])
  @@index([victory])
  @@map("game_results")
}

model PlayerGameResult {
  id              String      @id @default(uuid()) @db.Uuid
  gameResultId    String      @db.Uuid
  userId          String      @db.Uuid
  characterId     String      @db.Uuid
  characterClass  String      @db.VarChar(50)
  characterName   String      @db.VarChar(30)

  // Survival stats
  survived        Boolean     @default(true)
  wasExhausted    Boolean     @default(false)

  // Combat stats
  damageDealt     Int         @default(0)
  damageTaken     Int         @default(0)
  monstersKilled  Int         @default(0)

  // Resource stats
  lootCollected   Int         @default(0)
  cardsLost       Int         @default(0)

  // Rewards
  experienceGained Int        @default(0)
  goldGained       Int        @default(0)

  createdAt       DateTime    @default(now())

  // Relations
  gameResult GameResult @relation(fields: [gameResultId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([gameResultId])
  @@index([userId])
  @@index([characterId])
  @@map("player_game_results")
}

// ========== CAMPAIGN SHOP SYSTEM (Issue #328) ==========

model CampaignShopInventory {
  id              String   @id @default(uuid()) @db.Uuid
  campaignId      String   @db.Uuid
  itemId          String   @db.Uuid
  quantity        Int      @db.SmallInt    // Current quantity in stock
  initialQuantity Int      @db.SmallInt    // Original quantity (for resetting)
  lastRestockedAt DateTime @default(now())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  campaign Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  item     Item     @relation(fields: [itemId], references: [id], onDelete: Cascade)

  // Unique constraint: one inventory record per campaign+item
  @@unique([campaignId, itemId])
  @@index([campaignId])
  @@index([itemId])
  @@map("campaign_shop_inventory")
}

model ShopTransaction {
  id             String          @id @default(uuid()) @db.Uuid
  campaignId     String          @db.Uuid
  characterId    String          @db.Uuid
  itemId         String          @db.Uuid
  transactionType TransactionType
  goldAmount     Int             // Gold spent (BUY) or received (SELL)
  quantity       Int             @default(1) @db.SmallInt // For future bulk transactions
  createdAt      DateTime        @default(now())

  // Relations
  campaign Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  character Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  item     Item     @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@index([campaignId])
  @@index([characterId])
  @@index([itemId])
  @@index([createdAt])
  @@map("shop_transactions")
}

// ========== CAMPAIGN TEMPLATES (Issue #244 - DB-driven campaigns) ==========

model CampaignTemplate {
  id                    String  @id @default(uuid()) @db.Uuid
  name                  String  @unique @db.VarChar(100)
  description           String? @db.VarChar(500)
  deathMode             String  @default("configurable") @db.VarChar(20) // "healing" | "permadeath" | "configurable"
  minPlayers            Int     @default(1) @db.SmallInt
  maxPlayers            Int     @default(4) @db.SmallInt
  requireUniqueClasses  Boolean @default(false) // Require each player to have unique character classes
  isActive              Boolean @default(true) // Can be used to create new campaigns
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  // Relations
  scenarios CampaignTemplateScenario[]
  campaigns Campaign[]

  @@map("campaign_templates")
}

model CampaignTemplateScenario {
  id               String  @id @default(uuid()) @db.Uuid
  templateId       String  @db.Uuid
  scenarioId       String  @db.VarChar(100) // References game scenario ID for both progression and gameplay loading
  name             String? @db.VarChar(100) // Optional override display name (uses scenario name if null)
  description      String? @db.VarChar(500) // Optional override description
  unlocksScenarios Json    @default("[]") // Array of game scenario IDs this unlocks on victory
  isStarting       Boolean @default(false) // Is this scenario unlocked at campaign start?
  sequence         Int     @db.SmallInt // Order in the campaign (for display)
  createdAt        DateTime @default(now())

  // Relations
  template CampaignTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  @@unique([templateId, scenarioId]) // Same scenario can't appear twice in same campaign
  @@index([templateId])
  @@map("campaign_template_scenarios")
}

// ========== CAMPAIGNS (Issue #244 - Campaign instances) ==========

model Campaign {
  id                    String   @id @default(uuid()) @db.Uuid
  templateId            String?  @db.Uuid // Reference to the template this campaign was created from
  name                  String   @db.VarChar(100)
  description           String?  @db.VarChar(500)
  prosperityLevel       Int      @default(1) @db.SmallInt
  reputation            Int      @default(0) @db.SmallInt
  completedScenarios    Json     @default("[]") // Array of scenario IDs
  deathMode             String   @default("healing") @db.VarChar(20) // "healing" | "permadeath"
  requireUniqueClasses  Boolean  @default(false) // Require each player to have unique character classes
  retiredCharacterIds   Json     @default("[]") // Array of retired character IDs (permadeath mode)
  unlockedScenarios     Json     @default("[]") // Array of unlocked scenario IDs available next
  isCompleted           Boolean  @default(false)
  completedAt           DateTime?
  shopConfig            Json     @default("{}") // CampaignShopConfig JSON (Issue #328)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  // Relations
  template      CampaignTemplate?       @relation(fields: [templateId], references: [id])
  characters    Character[]
  games         Game[]                  // Games played in this campaign (Issue #244)
  shopInventory CampaignShopInventory[] // Shop inventory (Issue #328)
  shopTransactions ShopTransaction[]     // Shop transactions (Issue #328)

  @@index([templateId])
  @@map("campaigns")
}

// ========== SCENARIOS (001 + 002) ==========

model Scenario {
  id                   String   @id @default(uuid()) @db.Uuid
  name                 String   @unique @db.VarChar(100)
  difficulty           Int      @db.SmallInt
  mapLayout            Json // Array of HexTile objects
  monsterGroups        Json // Array of MonsterGroup objects
  objectives           Json // { primary, secondary }
  treasures            Json? // Array of treasure locations
  playerStartPositions Json? // Array of starting hex coordinates
  createdAt            DateTime @default(now())

  // Background image configuration (Issue #191)
  backgroundImageUrl   String?  @db.VarChar(500) // URL or path to background image
  backgroundOpacity    Float?   @default(1.0) // Opacity 0.0 to 1.0
  backgroundOffsetX    Int?     @default(0) // X offset in pixels
  backgroundOffsetY    Int?     @default(0) // Y offset in pixels
  backgroundScale      Float?   @default(1.0) // Scale multiplier (0.5 to 3.0)
  backgroundAnchors    Json?    // Two-anchor alignment data (Issue #191)

  // Relations
  games     Game[]
  narrative ScenarioNarrative?

  @@index([difficulty])
  @@map("scenarios")
}

// ========== SCENARIO NARRATIVES (Campaign Narrative Feature) ==========

model ScenarioNarrative {
  id              String   @id @default(uuid()) @db.Uuid
  scenarioId      String   @unique @db.Uuid

  // Before scenario narrative (intro)
  introTitle      String?  @db.VarChar(200)
  introText       String?  @db.Text
  introImageUrl   String?  @db.VarChar(500)

  // After scenario narrative (victory)
  victoryTitle    String?  @db.VarChar(200)
  victoryText     String?  @db.Text
  victoryImageUrl String?  @db.VarChar(500)
  victoryRewards  Json?    // { gold?: number, xp?: number, items?: string[], distribution?: string }

  // After scenario narrative (defeat)
  defeatTitle     String?  @db.VarChar(200)
  defeatText      String?  @db.Text
  defeatImageUrl  String?  @db.VarChar(500)
  defeatRewards   Json?    // { gold?: number, xp?: number, items?: string[], distribution?: string }

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  scenario  Scenario           @relation(fields: [scenarioId], references: [id], onDelete: Cascade)
  triggers  NarrativeTrigger[]

  @@map("scenario_narratives")
}

model NarrativeTrigger {
  id              String   @id @default(uuid()) @db.Uuid
  narrativeId     String   @db.Uuid

  // Trigger identification
  triggerId       String   @db.VarChar(100) // Unique identifier per scenario
  displayOrder    Int      @default(0) @db.SmallInt // Order if multiple triggers fire

  // Narrative content
  title           String?  @db.VarChar(200)
  text            String   @db.Text
  imageUrl        String?  @db.VarChar(500)

  // Trigger conditions (JSON - NarrativeCondition structure from shared/types/narrative.ts)
  conditions      Json

  // Optional rewards when narrative is acknowledged
  rewards         Json?    // { gold?: number, xp?: number }

  // Optional game effects to apply after all players acknowledge
  gameEffects     Json?    // { spawnMonsters?: [...], unlockDoors?: [...] }

  createdAt       DateTime @default(now())

  // Relations
  narrative  ScenarioNarrative @relation(fields: [narrativeId], references: [id], onDelete: Cascade)

  @@index([narrativeId])
  @@map("narrative_triggers")
}

// ========== ANONYMOUS GAMEPLAY (001 - Legacy) ==========

// GameRoom and Player models are kept for backward compatibility
// with existing 001 anonymous gameplay. New authenticated games use Game model.

model GameRoom {
  id         String     @id @default(uuid()) @db.Uuid
  roomCode   String     @unique @db.VarChar(6)
  status     RoomStatus @default(lobby)
  scenarioId String?    @db.Uuid
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  expiresAt  DateTime // 24-hour TTL for anonymous games

  // Relations
  players Player[]

  @@index([roomCode])
  @@index([status])
  @@index([expiresAt])
  @@map("game_rooms")
}

model Player {
  id               String           @id @default(uuid()) @db.Uuid
  uuid             String           @unique @db.VarChar(36)
  nickname         String           @db.VarChar(50)
  roomId           String?          @db.Uuid
  isHost           Boolean          @default(false)
  connectionStatus ConnectionStatus @default(connected)
  lastSeenAt       DateTime         @default(now())
  createdAt        DateTime         @default(now())

  // Relations
  room GameRoom? @relation(fields: [roomId], references: [id], onDelete: SetNull)

  @@index([uuid])
  @@index([roomId])
  @@map("players")
}

// ========== ENUMS ==========

enum GameStatus {
  LOBBY
  ACTIVE
  COMPLETED
  ABANDONED

  @@map("game_status")
}

enum RoomStatus {
  lobby
  active
  completed
  abandoned

  @@map("room_status")
}

enum ConnectionStatus {
  connected
  disconnected
  reconnecting

  @@map("connection_status")
}

enum EnhancementSlot {
  TOP
  BOTTOM

  @@map("enhancement_slot")
}

enum Rarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY

  @@map("rarity")
}

// ========== ITEM ENUMS (Issue #205) ==========

enum ItemSlot {
  HEAD
  BODY
  LEGS
  ONE_HAND
  TWO_HAND
  SMALL

  @@map("item_slot")
}

enum ItemUsageType {
  PERSISTENT // No usage limits
  SPENT      // Refresh on long rest
  CONSUMED   // Refresh between scenarios

  @@map("item_usage_type")
}

enum ItemState {
  READY    // Item is ready to use
  SPENT    // Item has been used, refreshes on long rest
  CONSUMED // Item has been consumed, refreshes between scenarios

  @@map("item_state")
}

// ========== SHOP SYSTEM (Issue #328) ==========

enum TransactionType {
  BUY
  SELL

  @@map("transaction_type")
}
