name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch: # Allow manual deployment

env:
  NODE_VERSION: '20'
  PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST || '150.136.88.138' }}
  DEPLOY_USER: 'ubuntu'
  DEPLOY_PATH: '/opt/hexhaven'

jobs:
  deploy:
    name: Deploy to Production Server
    runs-on: ubuntu-latest
    environment: production # Use GitHub environment for protection rules

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies (monorepo)
        run: npm ci

      - name: Run tests
        run: |
          npm run test || echo "Tests completed"
          npm run lint || echo "Linting completed"

      - name: Build backend
        run: npm run build -w backend

      - name: Build frontend
        run: npm run build -w frontend
        env:
          VITE_API_URL: http://${{ env.PRODUCTION_HOST }}
          NODE_ENV: production

      - name: Create deployment archive
        run: |
          mkdir -p deploy-production

          # Copy monorepo root files (for npm workspaces)
          cp package.json deploy-production/
          cp package-lock.json deploy-production/

          # Copy backend workspace (including dist and package files)
          mkdir -p deploy-production/backend
          cp -r backend/dist deploy-production/backend/
          cp -r backend/prisma deploy-production/backend/
          cp backend/package.json deploy-production/backend/

          # Copy frontend build
          mkdir -p deploy-production/frontend
          cp -r frontend/dist/* deploy-production/frontend/

          # Copy deployment scripts
          cp scripts/deploy.sh deploy-production/
          cp scripts/server-config.sh deploy-production/
          chmod +x deploy-production/deploy.sh
          chmod +x deploy-production/server-config.sh

          # Copy PM2 ecosystem configuration
          cp ecosystem.config.js deploy-production/

          # Copy Nginx configuration
          cp infrastructure/nginx-hexhaven.conf deploy-production/

          # Create archive
          tar -czf deploy.tar.gz deploy-production/
          ls -lh deploy.tar.gz
          echo "Archive contents:"
          tar -tzf deploy.tar.gz | head -20

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          # Write SSH key with proper newline handling
          printf '%s\n' "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/production_key
          chmod 600 ~/.ssh/production_key

          # Validate SSH key format
          if ! ssh-keygen -l -f ~/.ssh/production_key > /dev/null 2>&1; then
            echo "Error: Invalid SSH key format!"
            echo "Please ensure PRODUCTION_SSH_KEY secret contains a valid private key with proper newlines."
            echo "Key should start with '-----BEGIN' and contain actual newlines (not \\n literals)"
            exit 1
          fi

          # Add host to known_hosts
          ssh-keyscan -H ${{ env.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

          # Test SSH connection (without executing commands)
          ssh -i ~/.ssh/production_key -o BatchMode=yes -o ConnectTimeout=10 ${{ env.DEPLOY_USER }}@${{ env.PRODUCTION_HOST }} exit || {
            echo "Error: SSH connection test failed!"
            echo "Please verify:"
            echo "1. PRODUCTION_SSH_KEY secret is set correctly (with actual newlines, not \\n)"
            echo "2. The corresponding public key is in ~/.ssh/authorized_keys on the server"
            echo "3. The ubuntu user exists on the production server"
            echo "4. SSH is enabled and accessible on the production server"
            exit 1
          }

      - name: Upload deployment package
        run: |
          scp -i ~/.ssh/production_key deploy.tar.gz ${{ env.DEPLOY_USER }}@${{ env.PRODUCTION_HOST }}:/tmp/

      - name: Deploy on server
        env:
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
        run: |
          ssh -i ~/.ssh/production_key ${{ env.DEPLOY_USER }}@${{ env.PRODUCTION_HOST }} << 'ENDSSH'
            set -e

            echo "Starting production deployment..."
            echo "Commit: $GITHUB_SHA"
            echo "Branch: $GITHUB_REF_NAME"
            echo "Run: $GITHUB_RUN_NUMBER"

            # Ensure Node.js is installed
            echo "Checking Node.js installation..."
            if ! command -v node &> /dev/null; then
              echo "Node.js not found, installing..."
              curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
              sudo apt-get install -y nodejs
              echo "Node.js installed: $(node --version)"
            else
              echo "Node.js already installed: $(node --version)"
            fi

            # Ensure PM2 is installed
            echo "Checking PM2 installation..."
            if ! command -v pm2 &> /dev/null; then
              echo "PM2 not found, installing globally..."
              sudo npm install -g pm2
              echo "PM2 installed: $(pm2 --version)"
            else
              echo "PM2 already installed: $(pm2 --version)"
            fi

            # TODO: PostgreSQL setup currently disabled
            # The application doesn't use the database yet - it loads data from JSON files
            # Uncomment this section when database integration is ready

            # # Ensure PostgreSQL is installed
            # echo "Checking PostgreSQL installation..."
            # if ! command -v psql &> /dev/null; then
            #   echo "PostgreSQL not found, installing..."
            #   sudo apt-get update
            #   sudo apt-get install -y postgresql postgresql-contrib
            #   sudo systemctl start postgresql
            #   sudo systemctl enable postgresql
            #   echo "PostgreSQL installed: $(psql --version)"

            #   # Create database and user for hexhaven
            #   echo "Setting up database..."
            #   sudo -u postgres psql -c "CREATE USER hexhaven_user WITH PASSWORD 'hexhaven_production_password_CHANGE_ME';" || true
            #   sudo -u postgres psql -c "CREATE DATABASE hexhaven_production OWNER hexhaven_user;"
            #   sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE hexhaven_production TO hexhaven_user;"
            #   echo "Database created. IMPORTANT: Update password in /opt/hexhaven/.server-config"
            # else
            #   echo "PostgreSQL already installed: $(psql --version)"

            #   # Check if database exists
            #   if ! sudo -u postgres psql -lqt | cut -d \| -f 1 | grep -qw hexhaven_production; then
            #     echo "Creating hexhaven_production database..."
            #     sudo -u postgres psql -c "CREATE USER hexhaven_user WITH PASSWORD 'hexhaven_production_password_CHANGE_ME';" || true
            #     sudo -u postgres psql -c "CREATE DATABASE hexhaven_production OWNER hexhaven_user;"
            #     sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE hexhaven_production TO hexhaven_user;"
            #     echo "Database created. IMPORTANT: Update password in /opt/hexhaven/.server-config"
            #   else
            #     echo "Database hexhaven_production already exists"
            #   fi
            # fi

            # Extract deployment package
            cd /tmp
            tar -xzf deploy.tar.gz

            # Stop existing backend process
            echo "Stopping existing backend..."
            pm2 stop hexhaven-backend || echo "No existing backend process to stop"
            pm2 delete hexhaven-backend || echo "No existing backend process to delete"

            # Backup current deployment
            if [ -d "${{ env.DEPLOY_PATH }}" ]; then
              BACKUP_PATH="${{ env.DEPLOY_PATH }}.backup.$(date +%Y%m%d_%H%M%S)"
              echo "Creating backup at $BACKUP_PATH"
              sudo cp -r ${{ env.DEPLOY_PATH }} $BACKUP_PATH
            fi

            # Deploy new version
            echo "Deploying new version..."
            sudo mkdir -p ${{ env.DEPLOY_PATH }}

            # Copy monorepo root files (for npm workspaces)
            sudo cp /tmp/deploy-production/package.json ${{ env.DEPLOY_PATH }}/
            sudo cp /tmp/deploy-production/package-lock.json ${{ env.DEPLOY_PATH }}/

            # Copy backend workspace
            sudo mkdir -p ${{ env.DEPLOY_PATH }}/backend
            sudo cp -r /tmp/deploy-production/backend/dist ${{ env.DEPLOY_PATH }}/backend/
            sudo cp -r /tmp/deploy-production/backend/prisma ${{ env.DEPLOY_PATH }}/backend/
            sudo cp /tmp/deploy-production/backend/package.json ${{ env.DEPLOY_PATH }}/backend/

            # Copy frontend build
            sudo mkdir -p ${{ env.DEPLOY_PATH }}/frontend
            sudo cp -r /tmp/deploy-production/frontend/* ${{ env.DEPLOY_PATH }}/frontend/

            # Copy deployment scripts and PM2 config
            sudo cp /tmp/deploy-production/deploy.sh ${{ env.DEPLOY_PATH }}/
            sudo cp /tmp/deploy-production/server-config.sh ${{ env.DEPLOY_PATH }}/
            sudo cp /tmp/deploy-production/ecosystem.config.js ${{ env.DEPLOY_PATH }}/

            # Create logs directory for PM2
            sudo mkdir -p ${{ env.DEPLOY_PATH }}/logs

            # Set ownership
            sudo chown -R ${{ env.DEPLOY_USER }}:${{ env.DEPLOY_USER }} ${{ env.DEPLOY_PATH }}

            # Initialize server configuration if needed
            echo "Setting up server configuration..."
            cd ${{ env.DEPLOY_PATH }}
            chmod +x server-config.sh

            # Initialize server config (creates /opt/hexhaven/.server-config if not exists)
            # Pass PRODUCTION_HOST as SERVER_IP for consistency
            sudo -u ${{ env.DEPLOY_USER }} env SERVER_IP=${{ env.PRODUCTION_HOST }} ./server-config.sh init

            # Generate .env file from server configuration
            echo "Generating environment configuration..."
            sudo -u ${{ env.DEPLOY_USER }} env SERVER_IP=${{ env.PRODUCTION_HOST }} ./server-config.sh generate

            # Run deployment script
            echo "Running deployment script..."
            cd ${{ env.DEPLOY_PATH }}
            chmod +x deploy.sh
            export GITHUB_SHA="$GITHUB_SHA"
            export GITHUB_REF_NAME="$GITHUB_REF_NAME"
            export GITHUB_RUN_NUMBER="$GITHUB_RUN_NUMBER"
            export SERVER_IP="${{ env.PRODUCTION_HOST }}"
            ./deploy.sh || {
              echo "Deployment script failed!"
              exit 1
            }

            # Copy frontend to Nginx location
            echo "Deploying frontend to Nginx..."
            sudo mkdir -p /var/www/hexhaven
            sudo cp -r ${{ env.DEPLOY_PATH }}/frontend /var/www/hexhaven/
            sudo chown -R www-data:www-data /var/www/hexhaven
            sudo chmod -R 755 /var/www/hexhaven

            # Install and configure Nginx
            if ! command -v nginx &> /dev/null; then
              echo "Installing Nginx..."
              sudo apt-get update
              sudo apt-get install -y nginx
              sudo systemctl enable nginx
              sudo systemctl start nginx
            fi

            # Install Nginx site configuration
            echo "Configuring Nginx..."
            # Replace placeholder with actual server IP
            sed "s/__SERVER_IP__/${{ env.PRODUCTION_HOST }}/g" ${{ env.DEPLOY_PATH }}/nginx-hexhaven.conf | sudo tee /etc/nginx/sites-available/hexhaven > /dev/null
            sudo ln -sf /etc/nginx/sites-available/hexhaven /etc/nginx/sites-enabled/hexhaven

            # Disable default site if it exists
            if [ -f /etc/nginx/sites-enabled/default ]; then
              sudo rm /etc/nginx/sites-enabled/default
            fi

            # Test and reload Nginx
            if sudo nginx -t; then
              sudo systemctl reload nginx
              echo "✓ Nginx configured and reloaded successfully"
            else
              echo "✗ Nginx configuration test failed"
              sudo nginx -t
              exit 1
            fi

            # Ensure firewall allows HTTP traffic (Oracle Cloud)
            echo "Configuring firewall..."
            if sudo iptables -L -n | grep -q "dpt:80.*ACCEPT"; then
              echo "✓ Port 80 already allowed"
            else
              echo "Opening port 80..."
              sudo iptables -I INPUT 6 -m state --state NEW -p tcp --dport 80 -j ACCEPT
              sudo netfilter-persistent save || sudo iptables-save | sudo tee /etc/iptables/rules.v4 > /dev/null
              echo "✓ Port 80 opened"
            fi

            # Start backend with PM2
            echo "Starting backend with PM2..."
            cd ${{ env.DEPLOY_PATH }}

            # Start the backend using PM2 ecosystem file
            pm2 start ecosystem.config.js --env production

            # Save PM2 configuration
            pm2 save

            # Configure PM2 to start on system boot (only needs to be done once)
            sudo env PATH=$PATH:/usr/bin pm2 startup systemd -u ${{ env.DEPLOY_USER }} --hp /home/${{ env.DEPLOY_USER }} || echo "PM2 startup already configured"

            # Wait and verify
            echo "Waiting for backend to start..."
            sleep 5

            # Check PM2 status
            if pm2 show hexhaven-backend > /dev/null 2>&1; then
              echo "✓ Backend is running under PM2"
              pm2 show hexhaven-backend
            else
              echo "✗ Backend failed to start"
              pm2 logs hexhaven-backend --lines 50 --nostream
              exit 1
            fi

            # Cleanup
            rm -rf /tmp/deploy-production /tmp/deploy.tar.gz

            echo "✓ Production deployment completed successfully!"
          ENDSSH

      - name: Verify deployment
        run: |
          echo "Waiting for application to be ready..."
          sleep 10

          # Check backend health
          echo "Checking backend health..."
          if curl -f http://${{ env.PRODUCTION_HOST }}/health 2>/dev/null; then
            echo "✓ Backend health check passed"
          else
            echo "⚠ Backend health check failed (may need configuration)"
          fi

          # Check frontend
          echo "Checking frontend..."
          if curl -f -I http://${{ env.PRODUCTION_HOST }}/ 2>/dev/null; then
            echo "✓ Frontend is accessible"
          else
            echo "⚠ Frontend check failed"
          fi

          echo ""
          echo "Production deployment verification completed"
          echo "URL: http://${{ env.PRODUCTION_HOST }}"

      - name: Cleanup SSH keys
        if: always()
        run: |
          rm -f ~/.ssh/production_key

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✓ Deployment successful"
          else
            echo "✗ Deployment failed"
          fi
