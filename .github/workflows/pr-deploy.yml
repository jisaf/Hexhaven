name: Deploy on PR

on:
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]

env:
  NODE_VERSION: '20'
  PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST || '129.213.88.197' }}
  DEPLOY_USER: 'ubuntu'
  DEPLOY_PATH: '/opt/hexhaven'

jobs:
  deploy:
    name: Deploy to Production Server
    runs-on: ubuntu-latest
    # Run in parallel - no job dependencies

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies (monorepo)
        run: npm ci

      - name: Run tests
        run: |
          npm run test || echo "Tests completed"
          npm run lint || echo "Linting completed"

      - name: Build backend
        run: npm run build -w backend

      - name: Build frontend
        run: npm run build -w frontend
        env:
          VITE_API_URL: http://${{ env.PRODUCTION_HOST }}
          NODE_ENV: production

      - name: Create deployment archive
        run: |
          mkdir -p deploy-production

          # Copy monorepo root files (for npm workspaces)
          cp package.json deploy-production/
          cp package-lock.json deploy-production/

          # Copy backend workspace (including dist and package files)
          mkdir -p deploy-production/backend
          cp -r backend/dist deploy-production/backend/
          cp -r backend/prisma deploy-production/backend/
          cp backend/package.json deploy-production/backend/

          # Copy frontend build
          mkdir -p deploy-production/frontend
          cp -r frontend/dist/* deploy-production/frontend/

          # Copy deployment scripts
          cp scripts/deploy.sh deploy-production/
          cp scripts/server-config.sh deploy-production/
          cp scripts/network-diagnostics.sh deploy-production/
          chmod +x deploy-production/deploy.sh
          chmod +x deploy-production/server-config.sh
          chmod +x deploy-production/network-diagnostics.sh

          # Copy PM2 ecosystem configuration
          cp ecosystem.config.js deploy-production/

          # Copy Nginx configuration
          cp infrastructure/nginx-hexhaven.conf deploy-production/

          # Create archive
          tar -czf deploy.tar.gz deploy-production/
          ls -lh deploy.tar.gz
          echo "Archive contents:"
          tar -tzf deploy.tar.gz | head -20

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          # Write SSH key with proper newline handling
          printf '%s\n' "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/production_key
          chmod 600 ~/.ssh/production_key

          # Validate SSH key format
          if ! ssh-keygen -l -f ~/.ssh/production_key > /dev/null 2>&1; then
            echo "Error: Invalid SSH key format!"
            echo "Please ensure PRODUCTION_SSH_KEY secret contains a valid private key with proper newlines."
            echo "Key should start with '-----BEGIN' and contain actual newlines (not \\n literals)"
            exit 1
          fi

          # Add host to known_hosts
          ssh-keyscan -H ${{ env.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

          # Test SSH connection (without executing commands)
          ssh -i ~/.ssh/production_key -o BatchMode=yes -o ConnectTimeout=10 ${{ env.DEPLOY_USER }}@${{ env.PRODUCTION_HOST }} exit || {
            echo "Error: SSH connection test failed!"
            echo "Please verify:"
            echo "1. PRODUCTION_SSH_KEY secret is set correctly (with actual newlines, not \\n)"
            echo "2. The corresponding public key is in ~/.ssh/authorized_keys on the server"
            echo "3. The ubuntu user exists on the production server"
            echo "4. SSH is enabled and accessible on the production server"
            exit 1
          }

      - name: Upload deployment package
        run: |
          scp -i ~/.ssh/production_key deploy.tar.gz ${{ env.DEPLOY_USER }}@${{ env.PRODUCTION_HOST }}:/tmp/

      - name: Deploy on server
        env:
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
        run: |
          ssh -i ~/.ssh/production_key ${{ env.DEPLOY_USER }}@${{ env.PRODUCTION_HOST }} << 'ENDSSH'
            set -e

            echo "Starting production deployment..."
            echo "Commit: $GITHUB_SHA"
            echo "Branch: $GITHUB_REF_NAME"
            echo "Run: $GITHUB_RUN_NUMBER"

            # Ensure Node.js is installed
            echo "Checking Node.js installation..."
            if ! command -v node &> /dev/null; then
              echo "Node.js not found, installing..."
              curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
              sudo apt-get install -y nodejs
              echo "Node.js installed: $(node --version)"
            else
              echo "Node.js already installed: $(node --version)"
            fi

            # Ensure PM2 is installed
            echo "Checking PM2 installation..."
            if ! command -v pm2 &> /dev/null; then
              echo "PM2 not found, installing globally..."
              sudo npm install -g pm2
              echo "PM2 installed: $(pm2 --version)"
            else
              echo "PM2 already installed: $(pm2 --version)"
            fi

            # Extract deployment package
            cd /tmp
            tar -xzf deploy.tar.gz

            # Stop existing backend process
            echo "Stopping existing backend..."
            pm2 stop hexhaven-backend || echo "No existing backend process to stop"
            pm2 delete hexhaven-backend || echo "No existing backend process to delete"

            # Backup current deployment
            if [ -d "${{ env.DEPLOY_PATH }}" ]; then
              BACKUP_PATH="${{ env.DEPLOY_PATH }}.backup.$(date +%Y%m%d_%H%M%S)"
              echo "Creating backup at $BACKUP_PATH"
              sudo cp -r ${{ env.DEPLOY_PATH }} $BACKUP_PATH

              # Keep only last 5 backups
              sudo ls -dt ${{ env.DEPLOY_PATH }}.backup.* 2>/dev/null | tail -n +6 | xargs sudo rm -rf
            fi

            # Deploy new version
            echo "Deploying new version..."
            sudo mkdir -p ${{ env.DEPLOY_PATH }}

            # Copy monorepo root files (for npm workspaces)
            sudo cp /tmp/deploy-production/package.json ${{ env.DEPLOY_PATH }}/
            sudo cp /tmp/deploy-production/package-lock.json ${{ env.DEPLOY_PATH }}/

            # Copy backend workspace
            sudo mkdir -p ${{ env.DEPLOY_PATH }}/backend
            sudo cp -r /tmp/deploy-production/backend/dist ${{ env.DEPLOY_PATH }}/backend/
            sudo cp -r /tmp/deploy-production/backend/prisma ${{ env.DEPLOY_PATH }}/backend/
            sudo cp /tmp/deploy-production/backend/package.json ${{ env.DEPLOY_PATH }}/backend/

            # Copy frontend build
            sudo mkdir -p ${{ env.DEPLOY_PATH }}/frontend
            sudo cp -r /tmp/deploy-production/frontend/* ${{ env.DEPLOY_PATH }}/frontend/

            # Create scripts directory if it doesn't exist
            sudo mkdir -p ${{ env.DEPLOY_PATH }}/scripts

            # Copy deployment scripts and PM2 config
            sudo cp /tmp/deploy-production/deploy.sh ${{ env.DEPLOY_PATH }}/
            sudo cp /tmp/deploy-production/server-config.sh ${{ env.DEPLOY_PATH }}/
            sudo cp /tmp/deploy-production/network-diagnostics.sh ${{ env.DEPLOY_PATH }}/scripts/
            sudo cp /tmp/deploy-production/ecosystem.config.js ${{ env.DEPLOY_PATH }}/
            sudo cp /tmp/deploy-production/nginx-hexhaven.conf ${{ env.DEPLOY_PATH }}/

            # Create logs directory for PM2
            sudo mkdir -p ${{ env.DEPLOY_PATH }}/logs

            # Set ownership
            sudo chown -R ${{ env.DEPLOY_USER }}:${{ env.DEPLOY_USER }} ${{ env.DEPLOY_PATH }}

            # Initialize server configuration if needed
            echo "Setting up server configuration..."
            cd ${{ env.DEPLOY_PATH }}
            chmod +x server-config.sh

            # Initialize server config (creates /opt/hexhaven/.server-config if not exists)
            sudo -u ${{ env.DEPLOY_USER }} env SERVER_IP=${{ env.PRODUCTION_HOST }} ./server-config.sh init

            # Generate .env file from server configuration
            echo "Generating environment configuration..."
            sudo -u ${{ env.DEPLOY_USER }} env SERVER_IP=${{ env.PRODUCTION_HOST }} ./server-config.sh generate

            # Run deployment script
            echo "Running deployment script..."
            cd ${{ env.DEPLOY_PATH }}
            chmod +x deploy.sh
            export GITHUB_SHA="$GITHUB_SHA"
            export GITHUB_REF_NAME="$GITHUB_REF_NAME"
            export GITHUB_RUN_NUMBER="$GITHUB_RUN_NUMBER"
            export SERVER_IP="${{ env.PRODUCTION_HOST }}"
            ./deploy.sh || {
              echo "Deployment script failed!"
              exit 1
            }

            # Copy frontend to Nginx location
            echo "Deploying frontend to Nginx..."
            sudo mkdir -p /var/www/hexhaven
            sudo cp -r ${{ env.DEPLOY_PATH }}/frontend /var/www/hexhaven/
            sudo chown -R www-data:www-data /var/www/hexhaven
            sudo chmod -R 755 /var/www/hexhaven

            # Install and configure Nginx
            if ! command -v nginx &> /dev/null; then
              echo "Installing Nginx..."
              sudo apt-get update
              sudo apt-get install -y nginx
              sudo systemctl enable nginx
              sudo systemctl start nginx
            fi

            # Install Nginx site configuration
            echo "Configuring Nginx..."
            # Replace placeholder with actual server IP
            sed "s/__SERVER_IP__/${{ env.PRODUCTION_HOST }}/g" ${{ env.DEPLOY_PATH }}/nginx-hexhaven.conf | sudo tee /etc/nginx/sites-available/hexhaven > /dev/null
            sudo ln -sf /etc/nginx/sites-available/hexhaven /etc/nginx/sites-enabled/hexhaven

            # Disable default site if it exists
            if [ -f /etc/nginx/sites-enabled/default ]; then
              sudo rm /etc/nginx/sites-enabled/default
            fi

            # Test and reload Nginx
            if sudo nginx -t; then
              sudo systemctl reload nginx
              echo "✓ Nginx configured and reloaded successfully"
            else
              echo "✗ Nginx configuration test failed"
              sudo nginx -t
              exit 1
            fi

            # Ensure firewall allows HTTP traffic (Oracle Cloud)
            echo "Configuring firewall..."
            if sudo iptables -L -n | grep -q "dpt:80.*ACCEPT"; then
              echo "✓ Port 80 already allowed"
            else
              echo "Opening port 80..."
              sudo iptables -I INPUT 6 -m state --state NEW -p tcp --dport 80 -j ACCEPT
              sudo netfilter-persistent save 2>/dev/null || sudo iptables-save | sudo tee /etc/iptables/rules.v4 > /dev/null
              echo "✓ Port 80 opened"
            fi

            # Verify deployment prerequisites before starting PM2
            echo "Verifying deployment prerequisites..."
            cd ${{ env.DEPLOY_PATH }}

            if [ ! -f .env ]; then
              echo "✗ ERROR: .env file not found at ${{ env.DEPLOY_PATH }}/.env"
              exit 1
            else
              echo "✓ .env file exists"
            fi

            if [ ! -d node_modules ]; then
              echo "✗ ERROR: node_modules not found"
              exit 1
            else
              echo "✓ node_modules exists"
            fi

            if [ ! -f backend/dist/backend/src/main.js ]; then
              echo "✗ ERROR: Backend entry point not found"
              exit 1
            else
              echo "✓ Backend build exists"
            fi

            # Start backend with PM2
            echo "Starting backend with PM2..."

            # Start the backend using PM2 ecosystem file
            pm2 start ecosystem.config.js --env production

            # Save PM2 configuration
            pm2 save

            # Configure PM2 to start on system boot (only needs to be done once)
            sudo env PATH=$PATH:/usr/bin pm2 startup systemd -u ${{ env.DEPLOY_USER }} --hp /home/${{ env.DEPLOY_USER }} || echo "PM2 startup already configured"

            # Wait and verify
            echo "Waiting for backend to start..."
            sleep 10

            # Check PM2 status and look for crash-looping
            if pm2 show hexhaven-backend > /dev/null 2>&1; then
              echo "✓ Backend process exists in PM2"

              # Get restart count
              RESTART_COUNT=$(pm2 show hexhaven-backend | grep "│ restarts" | grep -v "unstable" | awk -F'│' '{print $3}' | tr -d ' ')

              # Validate it's a number, otherwise default to 0
              if ! [[ "$RESTART_COUNT" =~ ^[0-9]+$ ]]; then
                echo "Warning: Could not parse restart count, defaulting to 0"
                RESTART_COUNT=0
              fi

              echo "Backend restart count: $RESTART_COUNT"

              if [ "$RESTART_COUNT" -gt 5 ]; then
                echo ""
                echo "=========================================="
                echo "✗ DEPLOYMENT FAILED: Backend is crash-looping!"
                echo "=========================================="
                echo "Restart count: $RESTART_COUNT"
                echo ""
                echo "--- PM2 Process Status ---"
                pm2 show hexhaven-backend
                echo ""
                echo "--- Last 100 lines of logs ---"
                pm2 logs hexhaven-backend --lines 100 --nostream || cat ${{ env.DEPLOY_PATH }}/logs/pm2-error.log
                echo ""
                exit 1
              fi

              pm2 show hexhaven-backend
              echo "✓ Backend is running successfully"
            else
              echo "✗ Backend failed to start"
              pm2 logs hexhaven-backend --lines 50 --nostream
              exit 1
            fi

            # Verify Nginx configuration
            echo ""
            echo "Verifying Nginx configuration..."
            if sudo systemctl is-active nginx > /dev/null 2>&1; then
              echo "✓ Nginx is running"
            else
              echo "✗ Nginx is not running"
              sudo systemctl status nginx
            fi

            # Test endpoints from server
            echo ""
            echo "Testing endpoints from server..."

            echo "Backend direct (localhost:3000):"
            if curl -f --max-time 5 http://localhost:3000/health 2>/dev/null; then
              echo "✓ Backend responds on localhost:3000"
            else
              echo "✗ Backend not accessible on localhost:3000"
            fi

            echo ""
            echo "Backend through Nginx (localhost:80):"
            if curl -f --max-time 5 http://localhost/health 2>/dev/null; then
              echo "✓ Backend accessible through Nginx on localhost"
            else
              echo "✗ Backend not accessible through Nginx"
            fi

            echo ""
            echo "Testing from public IP (${{ env.PRODUCTION_HOST }}):"
            if curl -f --max-time 5 http://${{ env.PRODUCTION_HOST }}/health 2>/dev/null; then
              echo "✓ Backend accessible from public IP"
            else
              echo "✗ Backend NOT accessible from public IP"
              echo ""
              echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
              echo "⚠  ORACLE CLOUD SECURITY LIST CONFIGURATION REQUIRED"
              echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
              echo ""
              echo "Your application is deployed and running, but the Oracle Cloud"
              echo "Security List is blocking public access on port 80."
              echo ""
              echo "TO FIX THIS (one-time setup):"
              echo "1. Go to: https://cloud.oracle.com"
              echo "2. Navigate to: Networking → Virtual Cloud Networks"
              echo "3. Select your VCN → Security Lists → Default Security List"
              echo "4. Click 'Add Ingress Rules'"
              echo "5. Configure:"
              echo "   - Source CIDR: 0.0.0.0/0"
              echo "   - IP Protocol: TCP"
              echo "   - Destination Port Range: 80"
              echo "6. Click 'Add Ingress Rules'"
              echo ""
              echo "For detailed instructions, see: infrastructure/DEPLOYMENT.md"
              echo ""
              echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            fi

            # Cleanup
            rm -rf /tmp/deploy-production /tmp/deploy.tar.gz

            echo ""
            echo "✓ Production deployment completed successfully!"
          ENDSSH

      - name: Verify deployment
        run: |
          echo "Waiting for application to be ready..."
          sleep 10

          echo "=== Deployment Verification ==="
          echo ""

          # Check backend health with detailed output
          echo "Checking backend health..."
          if curl -v -f --max-time 10 http://${{ env.PRODUCTION_HOST }}/health 2>&1 | tee /tmp/health-check.log; then
            echo "✓ Backend health check passed"
          else
            echo "✗ Backend health check failed"
            echo "Error details:"
            cat /tmp/health-check.log
            echo ""
            echo "This could be due to:"
            echo "  1. Oracle Cloud Security List not allowing port 80 ingress"
            echo "  2. Nginx not properly configured"
            echo "  3. Backend not listening on port 3000"
            echo ""
            echo "To diagnose on the server, SSH in and run:"
            echo "  curl http://localhost:3000/health  # Test backend directly"
            echo "  curl http://localhost/health       # Test through Nginx"
            echo "  sudo systemctl status nginx        # Check Nginx status"
            echo "  sudo nginx -t                      # Test Nginx config"
            echo "  pm2 logs hexhaven-backend         # Check backend logs"
          fi

          echo ""

          # Check frontend
          echo "Checking frontend..."
          if curl -v -f -I --max-time 10 http://${{ env.PRODUCTION_HOST }}/ 2>&1 | tee /tmp/frontend-check.log; then
            echo "✓ Frontend is accessible"
          else
            echo "✗ Frontend check failed"
            echo "Error details:"
            cat /tmp/frontend-check.log
          fi

          echo ""
          echo "=== Deployment Summary ==="
          echo "URL: http://${{ env.PRODUCTION_HOST }}"
          echo "PR: ${{ github.event.pull_request.html_url }}"
          echo "Commit: ${{ github.sha }}"
          echo ""

      - name: Cleanup SSH keys
        if: always()
        run: |
          rm -f ~/.ssh/production_key

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✓ Deployment successful"
          else
            echo "✗ Deployment failed"
          fi
